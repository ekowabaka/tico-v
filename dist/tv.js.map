{"version":3,"file":"tv.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;;;;;;;;;;;;;;;AC/KA;;AAEA;;AAEA;AACA;AACA,oCAAoC,2BAA2B;AAC/D,mCAAmC,+CAA+C;AAClF,uCAAuC,iEAAiE;AACxG,gCAAgC,6CAA6C;AAC7E,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,OAAO;AACtB;AACA;AACA;AACA,yBAAyB,mDAAmD;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAA+C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oEAAoE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB,cAAc;AACd,2EAA2E,KAAK,EAAE,uBAAuB,EAAE,eAAe,aAAa,EAAE;AACzI;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnQA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;UClGA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;ACNyC;AACW;AACC;;;AAGrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;AACA;AACA,kCAAkC,MAAM,8DAAa;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8DAAa;AACzC;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,kDAAS;AACnC;AACA,yBAAyB,6DAAe;AACxC;AACA,IAAI;AACJ;AACA;AACA","sources":["webpack://tv/webpack/universalModuleDefinition","webpack://tv/./src/manipulators.js","webpack://tv/./src/parsers.js","webpack://tv/./src/update_handlers.js","webpack://tv/webpack/bootstrap","webpack://tv/webpack/runtime/define property getters","webpack://tv/webpack/runtime/hasOwnProperty shorthand","webpack://tv/webpack/runtime/make namespace object","webpack://tv/./src/ticoview.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tv\"] = factory();\n\telse\n\t\troot[\"tv\"] = factory();\n})(self, () => {\nreturn ","/**\n * manipulators.js\n * \n * Tico-V directly manipulates the DOM with the manipulators defined in this file. Each of these manipulators can\n * be attached to particular tico-v elements within the DOM. Whenever data changes, manipulators are called to update\n * the DOM.\n */\n\n/**\n * A utility function for rendering a text string when given a the parsed tree genereted by the text parser.\n * \n * @param {Array} structure \n * @param {Object} data \n */\nfunction renderText(structure, data) {\n  return structure.reduce((string, segment) => {\n    switch (segment.type) {\n      case 'var': return string + data[segment.name];\n      case 'txt': return string + segment.value;\n      case 'cond': return string + (data[segment.var1] ? data[segment.var1] : data[segment.var2]);\n      case 'condstr': return string + (data[segment.var1] ? segment.var2 : \"\");\n      case 'condstrelse': return string + (data[segment.var1] ? segment.var2 : segment.var3);\n    }\n  }, \"\");\n}\n\n/**\n * Responsible for manipulating text nodes in the DOM.\n * \n * @param {Object} entry \n */\nclass TextNodeManipulator {\n\n  #entry\n\n  constructor(entry) {\n    this.#entry = entry\n  }\n\n  update(data, node) {\n    (node || this.#entry.node).textContent = renderText(this.#entry.structure, data)\n  }\n}\n\n\n/**\n * Responsible for manipulating the values of attributes on DOM elements.\n * \n * @param {Object} entry \n */\nclass AttributeManipulator {\n  #entry\n\n  constructor(entry) {\n    this.#entry = entry\n  }\n\n  update(data, node) {\n    (node || this.#entry.node).value = renderText(this.#entry.structure, data)\n  }\n}\n\n/**\n * Responsible for showing or hiding nodes based on the data passed.\n * \n * @param {Object} entry \n * @param {boolean} invert \n */\nclass TruthAttributeManipulator {\n\n  #entry\n  #invert\n\n  constructor(entry, invert) {\n    this.#entry = entry\n    this.#invert = invert\n  }\n\n  update(data, node) {\n    let final = node || this.#entry.node;\n    if ((data[this.#entry.name] && !this.#invert) || (!data[this.#entry.name] && this.#invert)) {\n      final.style.display = this.#entry.display;\n    } else {\n      final.style.display = 'none';\n    }\n  }\n}\n\nclass ForeachManipulator {\n\n  #entry\n  #manipulators\n\n  constructor(entry, bindingDetails) {\n    this.#entry = entry\n    this.#manipulators = DomManipulators.create(entry.variables, bindingDetails)\n    this.#entry.manipulators = this.#manipulators\n  }\n\n  #dispatchEvents(nodes, data) {\n    const event = new Event(\"tv-update\");\n    event.detail = {nodes: nodes.filter(x => x.nodeType != Node.TEXT_NODE || x.nodeValue.trim() != \"\"), data: data}\n    this.#entry.parent.dispatchEvent(event)\n  }\n\n  update (data) {\n    data = data[this.#entry.name];\n    this.#entry.parent.innerHTML = \"\";\n    if (!Array.isArray(data)) {\n      return;\n    }\n    for (let row of data) {\n      const newNodes = [];\n      this.#manipulators.forEach(manipulator => manipulator.update(row));\n      this.#entry.template.forEach(x => {\n        const newNode = x.cloneNode(true);\n        newNodes.push(newNode);\n        this.#entry.parent.appendChild(newNode);\n      });\n      this.#dispatchEvents(newNodes, row);\n    }\n  }\n\n  set (key, data) {\n    const newNodes = [];\n    this.#manipulators.forEach(manipulator => manipulator.update(data));\n\n    this.#entry.template.forEach((x, offset) => {\n      const newNode = x.cloneNode(true);\n      newNodes.push(newNode);\n      if (key * this.#entry.template.length + offset === this.#entry.parent.childNodes.length) {\n        this.#entry.parent.appendChild(newNode);\n      } else {\n        this.#entry.parent.replaceChild(newNode, this.#entry.parent.childNodes[key * this.#entry.template.length + offset]);\n      }\n    });\n    this.#dispatchEvents(newNodes, data);\n  }\n}\n\n/**\n * A factory for creating manipulators based on the type of the entry.\n */\nconst DomManipulators = {\n  create: function (variables, bindingDetails) {\n    let manipulators = [];\n    let manipulator;\n\n    variables.forEach(variable => {\n      variable.forEach(entry => {\n        switch (entry.type) {\n          case 'text':\n            manipulator = new TextNodeManipulator(entry);\n            break;\n          case 'attribute':\n            manipulator = new AttributeManipulator(entry);\n            break;\n          case 'truth':\n            manipulator = new TruthAttributeManipulator(entry, false);\n            break;\n          case 'not-truth':\n            manipulator = new TruthAttributeManipulator(entry, true);\n            break;\n          case 'foreach':\n            manipulator = new ForeachManipulator(entry, bindingDetails);\n            break;\n          default: throw `Unknown type ${entry.type}`\n        }\n        manipulator.variables = entry;\n        manipulators.push(manipulator);\n      });\n    });\n\n    return manipulators;\n  }\n}\n\nexport {DomManipulators}","class TextParser {\n\n    #regexes\n\n    constructor() {\n        this.#regexes = {\n            variable: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*}}`, 'i'),\n            condstr: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*\"([^\"]*)\"\\\\s*}}`, 'i'),\n            condstrelse: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*\"([^\"]*)\"\\\\s*:\\\\s*\"([^\"]*)\"\\\\s*}}`, 'i'),\n            cond: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*([^\"]*)\\\\s*}}`, 'i'),\n            text: new RegExp(`{{`, 'i')\n        };\n    }\n\n    /**\n     * Push the leading text from a variable match unto the parsed list\n     *\n     * @param {string} text\n     * @param {*} match\n     * @param {Array} parsed\n     */\n    #pushLeadingText(text, match, parsed) {\n        if (match.index > 0) {\n            parsed.push({type: 'txt', value: text.substring(0, match.index)});\n        }\n    }\n\n    parse (text) {\n        let values = [];\n        let vars = new Set();\n        let order = ['variable', 'condstrelse', 'condstr', 'cond', 'text'];\n        let index = 0;\n        let lastIndex = undefined;\n\n        // Break the text up into specific identified chunks\n        while (text.length > 0) {\n            let match = null;\n            if (lastIndex !== undefined && lastIndex === index) {\n                throw `Error parsing ${text}`\n            }\n            lastIndex = index;\n\n            // Loop through the regexes in the order specified\n            for (let i in order) {\n                if (text.length === 0) break;\n                match = this.#regexes[order[i]].exec(text);\n                if (match) {\n                    index = match.index + match[0].length;\n                    switch (order[i]) {\n                        case 'variable':\n                            this.#pushLeadingText(text, match, values);\n                            values.push({type: 'var', name: match[1]});\n                            vars.add(match[1]);\n                            text = text.substr(index, text.length - index);\n                            break;\n                        case 'condstr':\n                        case 'cond':\n                            this.#pushLeadingText(text, match, values);\n                            values.push({type: order[i], var1: match[1], var2: match[2]});\n                            vars.add(match[1]);\n                            text = text.substr(index, text.length - index);\n                            if (order[i] === 'cond') vars.add(match[2]);\n                            break;\n                        case 'condstrelse':\n                            this.#pushLeadingText(text, match, values);\n                            values.push({type: 'condstrelse', var1: match[1], var2: match[2], var3: match[3]});\n                            vars.add(match[1]);\n                            text = text.substr(index, text.length - index);\n                            break;\n                        case 'text':\n                            this.#pushLeadingText(text, match, values);\n                            text = text.substr(match.index, text.length - match.index);\n                            break;\n                    }\n                }\n                if (match) break;\n            }\n\n            // If none of the regexes match return the remaining part of the string as is\n            if (match === null && text.length > 0) {\n                values.push({type: 'txt', value: text});\n                break;\n            }\n        }\n        return {variables: vars, structure: values}\n    }\n}\n\n\n/**\n * Parses dom nodes for those with supported tv-* attributes.\n */\nclass DomParser {\n\n    #textParser\n    #attributeRegexes\n\n    constructor() {\n        this.#textParser = new TextParser();\n        this.#attributeRegexes = [\"tv-foreach\", \"tv-true\", \"tv-not-true\", \"(tv-value)-([a-z0-9_\\-]+)\", \"(tv-).*\"].map(regex => new RegExp(regex, 'i'));\n\n    }\n\n    /**\n     * Add a variable extracted from a node to the variables object\n     *\n     * @param {Map} variables\n     * @param {string} variable\n     * @param {object} nodeDetails\n     */\n    #addNodeToVariable(variables, variable, nodeDetails) {\n        if (!variables.has(variable)) {\n            variables.set(variable, []);\n        }\n        variables.get(variable).push(nodeDetails);\n    }\n\n    /**\n     * Merge one set of variables into another\n     *\n     * @param {Map} variables\n     * @param {Map} mergedVariables\n     */\n    #mergeVariables(variables, mergedVariables) {\n        mergedVariables.forEach((details, variable) => {\n            if (variables.has(variable)) {\n                variables.get(variable).concat(details);\n            } else {\n                variables.set(variable, details)\n            }\n        });\n    }\n\n    /**\n     * Parse a given node for variables in its attributes that can be rendered later.\n     * This method returns a parent object in cases where the attribute dictates a foreach loop.\n     *\n     * @param {Node} node\n     * @param {Map} variables\n     * @param {string} path\n     */\n    #parseAttributes(node, variables, path) {\n        let parentDetected = false;\n        const attributeVariables = new Map();\n        let id;\n\n        for (const attribute of node.attributes) {\n            for (const regex of this.#attributeRegexes) {\n                const match = regex.exec(attribute.name);\n                if (!match) continue;\n\n                if (match[1] === 'tv-value') {\n                    // Extract and create attribute nodes on the fly.\n                    const attributeNode = document.createAttribute(match[2]);\n                    const parsed = this.#textParser.parse(attribute.value);\n                    node.setAttributeNode(attributeNode);\n\n                    parsed.variables.forEach(variable => {\n                        this.#addNodeToVariable(attributeVariables, variable,\n                            {\n                                node: attributeNode,\n                                type: 'attribute',\n                                name: match[2],\n                                structure: parsed.structure,\n                                path: path\n                            }\n                        )\n                    });\n                } else if (match[0] === 'tv-true') {\n                    // Hide and display nodes according to the truthiness of variables.\n                    this.#addNodeToVariable(attributeVariables, attribute.value,\n                        {node: node, type: 'truth', name: attribute.value, display: node.style.display, path: path}\n                    )\n                } else if (match[0] === 'tv-not-true') {\n                    // Hide and display nodes according to the truthiness of variables.\n                    this.#addNodeToVariable(attributeVariables, attribute.value,\n                        {node: node, type: 'not-truth', name: attribute.value, display: node.style.display, path: path}\n                    )\n                } else if (match[0] === 'tv-foreach') {\n                    parentDetected = {\n                        template: node.childNodes,\n                        childElementCount: node.childElementCount,\n                        type: 'foreach',\n                        parent: node,\n                        name: attribute.value,\n                        variables: attributeVariables,\n                        path: path,\n                        id: null\n                    };\n                    this.#addNodeToVariable(variables, attribute.value, parentDetected)\n                }\n                break;\n            }\n        }\n\n        if (!parentDetected) {\n            this.#mergeVariables(variables, attributeVariables);\n        } else if (parentDetected && id) {\n            parentDetected['id'] = id;\n        }\n        attributeVariables.forEach(x => x.path)\n        return parentDetected;\n    }\n\n    /**\n     * Parse an element node and its children to find any text nodes or attributes that contain variables to which\n     * bindings can be created.\n     *\n     * @param {Node} node\n     * @param {Map} variables\n     */\n    #parseNode(node, variables, path) {\n        const parentDetected = this.#parseAttributes(node, variables, path);\n        let children;\n\n        if (parentDetected) {\n            variables = parentDetected.variables;\n            children = Array.from(node.childNodes).map(x => x.cloneNode(true));\n        } else {\n            children = node.childNodes;\n        }\n\n        let n = 1;\n        children.forEach((child, index) => {\n            let parsed = [];\n\n            if (child.nodeType === Node.TEXT_NODE) {\n                parsed = this.#textParser.parse(child.textContent);\n                parsed.variables.forEach(variable => {\n                    this.#addNodeToVariable(variables, variable,\n                        {\n                            node: child,\n                            type: 'text',\n                            structure: parsed.structure,\n                            path: path,\n                            index: index\n                        });\n                });\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                this.#parseNode(child, variables, parentDetected ? \"\" : `${path}${path === \"\" ? \"\" : \">\"}${child.nodeName}:nth-child(${n})`)\n                n++;\n            }\n        });\n\n        if (parentDetected) {\n            parentDetected.template = children;\n        }\n    }\n\n    /**\n     * Parse a dom node and return a collection of variables their associated list of observers\n     * and related dom manipulators.\n     * @param {Node} templateNode\n     */\n    parse(templateNode) {\n        const variables = new Map();\n        this.#parseNode(templateNode, variables, \"\");\n        return variables;\n    }\n}\n\nexport {DomParser}","class ArrayUpdateHandler {\n\n    #entries\n    #manipulators\n    #proxyCache\n    #proxiesCreated\n\n    constructor(entries, manipulators) {\n        this.#entries = entries;\n        this.#manipulators = manipulators;\n        this.#proxyCache = new WeakMap();\n        this.#proxiesCreated = new WeakMap();\n    }\n\n    get(target, name) {\n        if (typeof target[name] === 'function' || typeof target[name] !== 'object') {\n            return target[name];\n        }\n\n        // Create the caches for the group of nodes based on the first entry of variables.\n        let node;\n        for (const entry of this.#entries) {\n            node = entry.parent.children[name];\n            if (!this.#proxyCache.has(node)) {\n                const proxy = new Proxy(target[name], new UpdateHandler(entry.variables, entry.manipulators, entry.parent.children[name]));\n                this.#proxyCache.set(node, proxy);\n                this.#proxiesCreated.set(proxy, target[name]);\n                break;\n            }\n        }\n        return this.#proxyCache.get(node);\n    }\n\n    set(target, name, value) {\n        // Prevent proxies already created from being added back to the array.\n        if (this.#proxiesCreated.has(value)) {\n            value = this.#proxiesCreated.get(value);\n        }\n        target[name] = value;\n        if (name === 'length') {\n            this.#entries.forEach(entry => {\n                for (let i = 0; i < entry.parent.children.length - value; i++) {\n                    entry.parent.removeChild(entry.parent.lastChild);\n                }\n            });\n            return true;\n        }\n        this.#manipulators.forEach(x => x.set != undefined && x.set(name, target[name]));\n        return true;\n    }\n}\n\n\nclass UpdateHandler {\n\n    #variables\n    #manipulators\n    #node\n\n    constructor(variables, manipulators, node) {\n        this.#variables = variables;\n        this.#manipulators = manipulators;\n        this.#node = node;\n    }\n\n    get(target, name) {\n        if (typeof target[name] === 'object' && Array.isArray(target[name]) && this.#variables.get(name)[0].type === \"foreach\") {\n            const updateHandler = new ArrayUpdateHandler(this.#variables.get(name), this.#manipulators);\n            return new Proxy(target[name], updateHandler);\n        } else if (typeof target[name] === 'object') {\n            return target[name];\n        } else {\n            return target[name];\n        }\n    }\n\n    set(target, name, value) {\n        target[name] = value;\n        this.run(target);\n        return true;\n    }\n\n    run(target) {\n        this.#manipulators.forEach(manipulator => {\n            let manipulatedNode = undefined;\n            if (this.#node) {\n                const baseNode = manipulator.variables.path === \"\" ? this.#node : this.#node.querySelector(manipulator.variables.path);\n                if (manipulator.variables.type == \"text\") {\n                    manipulatedNode = baseNode.childNodes[manipulator.variables.index];\n                } else if (manipulator.variables.type == \"attribute\") {\n                    manipulatedNode = baseNode.getAttributeNode(manipulator.variables.name);\n                } else {\n                    manipulatedNode = baseNode;\n                }\n            }\n            manipulator.update(target, manipulatedNode)\n        });\n    }\n}\n\nexport {UpdateHandler, ArrayUpdateHandler}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { DomParser } from \"./parsers.js\";\nimport { DomManipulators } from \"./manipulators.js\";\nimport { UpdateHandler } from \"./update_handlers.js\";\n\n\n/**\n * A view contains the dom elements with associated tico-v tags that can be bound to data items.\n */\nclass View {\n\n  #dataProxy\n  #variables\n  #manipulators;\n\n  /**\n   * Create a new Tico View\n   * @param {*} variables \n   * @param {*} manipulators\n   */\n  constructor(variables, manipulators) {\n    this.#dataProxy = new Proxy({}, new UpdateHandler(variables, manipulators))\n    this.#variables = variables;\n    this.#manipulators = manipulators;\n  }\n\n  /**\n   * Setter for the data variable.\n   * @param newData\n   */\n  set data(newData) {\n    let updateHandler = new UpdateHandler(this.#variables, this.#manipulators);\n    this.#dataProxy = new Proxy(newData, updateHandler);\n    updateHandler.run(newData);\n  }\n\n  /**\n   * Getter for the data variable.\n   * @returns {*}\n   */\n  get data() {\n    return this.#dataProxy;\n  }\n}\n\n/**\n * Bind a view to a mapping of its internal variables.\n */\nexport function bind(template) {\n  const templateNode = typeof template === 'string' ? document.querySelector(template) : template;\n  if (templateNode) {\n    const domparser = new DomParser();\n    const variables = domparser.parse(templateNode);\n    const manipulators = DomManipulators.create(variables); \n    return new View(variables, manipulators);\n  } else {\n    throw new Error(\"Could not find template node\");\n  }\n}\n"],"names":[],"sourceRoot":""}