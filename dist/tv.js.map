{"version":3,"file":"tv.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;ACnNxB;;AAEA;;AAEA;AACA;AACA,oCAAoC,2BAA2B;AAC/D,mCAAmC,+CAA+C;AAClF,uCAAuC,iEAAiE;AACxG,gCAAgC,6CAA6C;AAC7E,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,OAAO;AACtB;AACA;AACA;AACA,yBAAyB,mDAAmD;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6DAA6D;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oEAAoE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,kBAAkB;AAClB;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iBAAiB;AACjB,cAAc;AACd,mFAAmF,KAAK,EAAE,uBAAuB,EAAE,eAAe,aAAa,EAAE;AACjJ;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;AChRlB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;UClGA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;ACNwC;AACW;AACC;;;AAGpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B,kDAAS;AACvC;AACA,6BAA6B,6DAAe;AAC5C;AACA,MAAM;AACN;AACA;AACA","sources":["webpack://tv/webpack/universalModuleDefinition","webpack://tv/./src/manipulators.js","webpack://tv/./src/parsers.js","webpack://tv/./src/update_handlers.js","webpack://tv/webpack/bootstrap","webpack://tv/webpack/runtime/define property getters","webpack://tv/webpack/runtime/hasOwnProperty shorthand","webpack://tv/webpack/runtime/make namespace object","webpack://tv/./src/ticoview.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tv\"] = factory();\n\telse\n\t\troot[\"tv\"] = factory();\n})(self, () => {\nreturn ","/**\n * manipulators.js\n *\n * Tico-V directly manipulates the DOM with the manipulators defined in this file. Each of these manipulators can\n * be attached to particular tico-v elements within the DOM. Whenever data changes, manipulators are called to update\n * the DOM.\n */\n\n/**\n * A utility function for rendering a text string when given a the parsed tree genereted by the text parser.\n *\n * @param {Array} structure\n * @param {Object} data\n */\nfunction renderText(structure, data) {\n    return structure.reduce((string, segment) => {\n        switch (segment.type) {\n            case 'var':\n                return string + data[segment.name];\n            case 'txt':\n                return string + segment.value;\n            case 'cond':\n                return string + (data[segment.var1] ? data[segment.var1] : data[segment.var2]);\n            case 'condstr':\n                return string + (data[segment.var1] ? segment.var2 : \"\");\n            case 'condstrelse':\n                return string + (data[segment.var1] ? segment.var2 : segment.var3);\n        }\n    }, \"\");\n}\n\n/**\n * Responsible for manipulating text nodes in the DOM.\n *\n * @param {Object} entry\n */\nclass TextNodeManipulator {\n\n    #entry\n\n    constructor(entry) {\n        this.#entry = entry\n    }\n\n    update(data, node) {\n        (node || this.#entry.node).textContent = renderText(this.#entry.structure, data)\n    }\n}\n\n\n/**\n * Responsible for manipulating the values of attributes on DOM elements.\n *\n * @param {Object} entry\n */\nclass AttributeManipulator {\n    #entry\n\n    constructor(entry) {\n        this.#entry = entry\n    }\n\n    update(data, node) {\n        (node || this.#entry.node).value = renderText(this.#entry.structure, data)\n    }\n}\n\nclass SetManipulator {\n    #entry\n\n    constructor(entry) {\n        this.#entry = entry\n    }\n\n    update(data, node) {\n        const final = node || this.#entry.node\n        if (data[this.#entry.name]) {\n            final.setAttribute(this.#entry.attribute, this.#entry.attribute);\n        } else if (final.hasAttribute(this.#entry.attribute)) {\n            final.removeAttribute(this.#entry.attribute)\n        }\n    }\n}\n\n/**\n * Responsible for showing or hiding nodes based on the data passed.\n *\n * @param {Object} entry\n * @param {boolean} invert\n */\nclass TruthAttributeManipulator {\n\n    #entry\n    #invert\n\n    constructor(entry, invert) {\n        this.#entry = entry\n        this.#invert = invert\n    }\n\n    update(data, node) {\n        const final = node || this.#entry.node\n        if ((data[this.#entry.name] && !this.#invert) || (!data[this.#entry.name] && this.#invert)) {\n            if (final.hasAttribute('hidden')) {\n                final.removeAttribute('hidden');\n            }\n        } else {\n            final.setAttribute('hidden', 'hidden');\n        }\n    }\n}\n\nclass ForeachManipulator {\n\n    #entry\n    #manipulators\n\n    constructor(entry, bindingDetails) {\n        this.#entry = entry\n        this.#manipulators = DomManipulators.create(entry.variables, bindingDetails)\n        this.#entry.manipulators = this.#manipulators\n    }\n\n    #dispatchEvents(nodes, data) {\n        const event = new Event(\"tv-update\");\n        event.detail = {\n            nodes: nodes.filter(x => x.nodeType !== Node.TEXT_NODE || x.nodeValue.trim() !== \"\"),\n            data: data\n        }\n        this.#entry.parent.dispatchEvent(event)\n    }\n\n    update(data) {\n        data = data[this.#entry.name];\n        this.#entry.parent.innerHTML = \"\";\n        if (!Array.isArray(data)) {\n            return;\n        }\n        for (let row of data) {\n            const newNodes = []\n            this.#manipulators.forEach(x => x.forEach(manipulator => manipulator.update(row)))\n            this.#entry.template.forEach(x => {\n                const newNode = x.cloneNode(true)\n                newNodes.push(newNode)\n                this.#entry.parent.appendChild(newNode)\n            });\n            this.#dispatchEvents(newNodes, row)\n        }\n    }\n\n    set(key, data) {\n        const newNodes = []\n        this.#manipulators.forEach(x => x.forEach(manipulator => manipulator.update(data)))\n\n        this.#entry.template.forEach((x, offset) => {\n            const newNode = x.cloneNode(true)\n            newNodes.push(newNode);\n            if (key * this.#entry.template.length + offset === this.#entry.parent.childNodes.length) {\n                this.#entry.parent.appendChild(newNode);\n            } else {\n                this.#entry.parent.replaceChild(newNode, this.#entry.parent.childNodes[key * this.#entry.template.length + offset])\n            }\n        });\n        this.#dispatchEvents(newNodes, data);\n    }\n}\n\n/**\n * A factory for creating manipulators based on the type of the entry.\n */\nclass DomManipulators {\n    static create(variables, bindingDetails) {\n        // let manipulators = [];\n        const manipulators = new Map()\n        let manipulator;\n\n        variables.forEach((entries, variable) => {\n            const variableManipulators = []\n            entries.forEach(entry => {\n                switch (entry.type) {\n                    case 'text':\n                        manipulator = new TextNodeManipulator(entry)\n                        break;\n                    case 'attribute':\n                        manipulator = new AttributeManipulator(entry)\n                        break;\n                    case 'truth':\n                        manipulator = new TruthAttributeManipulator(entry, false)\n                        break;\n                    case 'not-truth':\n                        manipulator = new TruthAttributeManipulator(entry, true)\n                        break;\n                    case 'foreach':\n                        manipulator = new ForeachManipulator(entry, bindingDetails)\n                        break;\n                    case 'set':\n                        manipulator = new SetManipulator(entry)\n                        break\n                    default:\n                        throw `Unknown type ${entry.type}`\n                }\n                manipulator.variables = entry;\n                variableManipulators.push(manipulator);\n            });\n            manipulators.set(variable, variableManipulators)\n        });\n\n        return manipulators;\n    }\n}\n\nexport {DomManipulators}\n","class TextParser {\n\n    #regexes\n\n    constructor() {\n        this.#regexes = {\n            variable: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*}}`, 'i'),\n            condstr: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*\"([^\"]*)\"\\\\s*}}`, 'i'),\n            condstrelse: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*\"([^\"]*)\"\\\\s*:\\\\s*\"([^\"]*)\"\\\\s*}}`, 'i'),\n            cond: new RegExp(`{{\\\\s*([a-z][a-z0-9_]*)\\\\s*\\\\?\\\\s*([^\"]*)\\\\s*}}`, 'i'),\n            text: new RegExp(`{{`, 'i')\n        }\n    }\n\n    /**\n     * Push the leading text from a variable match unto the parsed list\n     *\n     * @param {string} text\n     * @param {*} match\n     * @param {Array} parsed\n     */\n    #pushLeadingText(text, match, parsed) {\n        if (match.index > 0) {\n            parsed.push({type: 'txt', value: text.substring(0, match.index)});\n        }\n    }\n\n    parse (text) {\n        let values = [];\n        let vars = new Set();\n        let order = ['variable', 'condstrelse', 'condstr', 'cond', 'text'];\n        let index = 0;\n        let lastIndex = undefined;\n\n        // Break the text up into specific identified chunks\n        while (text.length > 0) {\n            let match = null;\n            if (lastIndex !== undefined && lastIndex === index) {\n                throw `Error parsing ${text}`\n            }\n            lastIndex = index;\n\n            // Loop through the regexes in the order specified\n            for (let i in order) {\n                if (text.length === 0) break;\n                match = this.#regexes[order[i]].exec(text)\n                if (match) {\n                    index = match.index + match[0].length\n                    switch (order[i]) {\n                        case 'variable':\n                            this.#pushLeadingText(text, match, values)\n                            values.push({type: 'var', name: match[1]})\n                            vars.add(match[1])\n                            text = text.substr(index, text.length - index)\n                            break;\n                        case 'condstr':\n                        case 'cond':\n                            this.#pushLeadingText(text, match, values);\n                            values.push({type: order[i], var1: match[1].trim(), var2: match[2].trim()})\n                            vars.add(match[1].trim())\n                            text = text.substr(index, text.length - index)\n                            if (order[i] === 'cond') vars.add(match[2].trim())\n                            break;\n                        case 'condstrelse':\n                            this.#pushLeadingText(text, match, values)\n                            values.push({type: 'condstrelse', var1: match[1], var2: match[2], var3: match[3]})\n                            vars.add(match[1])\n                            text = text.substr(index, text.length - index)\n                            break;\n                        case 'text':\n                            this.#pushLeadingText(text, match, values)\n                            text = text.substr(match.index, text.length - match.index)\n                            break\n                    }\n                }\n                if (match) break\n            }\n\n            // If none of the regexes match return the remaining part of the string as is\n            if (match === null && text.length > 0) {\n                values.push({type: 'txt', value: text})\n                break\n            }\n        }\n        return {variables: vars, structure: values}\n    }\n}\n\n\n/**\n * Parses dom nodes for those with supported tv-* attributes.\n */\nclass DomParser {\n\n    #textParser\n    #attributeRegexes\n\n    constructor() {\n        this.#textParser = new TextParser()\n        this.#attributeRegexes = [\n            \"tv-foreach\", \"tv-true\", \"tv-not-true\", \"(tv-value)-([a-z0-9_\\-]+)\", \"(tv-set)-([a-z0-9_\\-]+)\", \"(tv-).*\"\n        ].map(regex => new RegExp(regex, 'i'))\n    }\n\n    /**\n     * Add a variable extracted from a node to the variables object\n     *\n     * @param {Map} variables\n     * @param {string} variable\n     * @param {object} nodeDetails\n     */\n    #addNodeToVariable(variables, variable, nodeDetails) {\n        if (!variables.has(variable)) {\n            variables.set(variable, [])\n        }\n        variables.get(variable).push(nodeDetails)\n    }\n\n    /**\n     * Merge one set of into into another\n     *\n     * @param {Map} into\n     * @param {Map} from\n     */\n    #mergeVariables(into, from) {\n        from.forEach((details, variable) => {\n            if (into.has(variable)) {\n                into.set(variable, into.get(variable).concat(details))\n            } else {\n                into.set(variable, details)\n            }\n        });\n    }\n\n    /**\n     * Parse a given node for variables in its attributes that can be rendered later.\n     * This method returns a parent object in cases where the attribute dictates a foreach loop.\n     *\n     * @param {Node} node\n     * @param {Map} variables\n     * @param {string} path\n     */\n    #parseAttributes(node, path) {\n\n        const response = {\n            parentVariable: null,\n            variables: new Map()\n        }\n\n        for (const attribute of node.attributes) {\n            for (const regex of this.#attributeRegexes) {\n                const match = regex.exec(attribute.name)\n                if (!match) continue\n\n                if (match[1] === 'tv-value') {\n                    // Extract and set attribute node values on the fly.\n                    const attributeNode = document.createAttribute(match[2])\n                    const parsed = this.#textParser.parse(attribute.value)\n                    node.setAttributeNode(attributeNode)\n\n                    parsed.variables.forEach(variable => {\n                        this.#addNodeToVariable(response.variables, variable,\n                            {\n                                node: attributeNode,\n                                type: 'attribute',\n                                name: match[2],\n                                structure: parsed.structure,\n                                path: path\n                            }\n                        )\n                    })\n                } else if (match[1] === 'tv-set') {\n                    // Extract and set the attribute node on the fly.\n                    this.#addNodeToVariable(response.variables, attribute.value,\n                        {\n                            node: node,\n                            type: 'set',\n                            name: attribute.value,\n                            path: path,\n                            attribute: match[2],\n                        })\n                } else if (match[0] === 'tv-true') {\n                    // Hide and display nodes according to the truthiness of variables.\n                    this.#addNodeToVariable(response.variables, attribute.value,\n                        {node: node, type: 'truth', name: attribute.value, display: node.style.display, path: path}\n                    )\n                } else if (match[0] === 'tv-not-true') {\n                    // Hide and display nodes according to the truthiness of variables.\n                    this.#addNodeToVariable(response.variables, attribute.value,\n                        {node: node, type: 'not-truth', name: attribute.value, display: node.style.display, path: path}\n                    )\n                } else if (match[0] === 'tv-foreach') {\n                    response.parentVariable = {\n                        template: node.childNodes,\n                        childElementCount: node.childElementCount,\n                        type: 'foreach',\n                        parent: node,\n                        name: attribute.value,\n                        variables: new Map(),\n                        path: path,\n                        id: null\n                    }\n                }\n                break;\n            }\n        }\n\n        return response\n    }\n\n    /**\n     * Parse an element node and its children to find any text nodes or attributes that contain variables to which\n     * bindings can be created.\n     *\n     * @param {Node} node\n     * @param {Map} variables\n     */\n    #parseNode(node, path) {\n        const variables = new Map()\n        const attributes = this.#parseAttributes(node, path);\n        let children;\n\n        if (attributes.parentVariable) {\n            // variables = parentDetected.variables;\n            children = Array.from(node.childNodes).map(x => x.cloneNode(true))\n            attributes.parentVariable.template = children\n        } else {\n            children = node.childNodes\n        }\n        this.#mergeVariables(variables, attributes.variables)\n\n        let n = 1;\n        children.forEach((child, index) => {\n            let parsed = [];\n\n            if (child.nodeType === Node.TEXT_NODE) {\n                parsed = this.#textParser.parse(child.textContent)\n                parsed.variables.forEach(variable => {\n                    this.#addNodeToVariable(variables, variable,\n                        {\n                            node: child,\n                            type: 'text',\n                            structure: parsed.structure,\n                            path: path,\n                            index: index\n                        })\n                })\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\n                const childVariables = this.#parseNode(child, attributes ? \"\" : `${path}${path === \"\" ? \"\" : \">\"}${child.nodeName}:nth-child(${n})`)\n                if (attributes.parentVariable) {\n                    this.#mergeVariables(attributes.parentVariable.variables, childVariables)\n                    this.#addNodeToVariable(variables, attributes.parentVariable.name, attributes.parentVariable)\n                } else {\n                    this.#mergeVariables(variables, childVariables)\n                }\n                n++\n            }\n        });\n\n        return variables\n    }\n\n    /**\n     * Parse a dom node and return a collection of variables their associated list of observers\n     * and related dom manipulators.\n     * @param {Node} templateNode\n     */\n    parse(templateNode) {\n        return this.#parseNode(templateNode, \"\")\n    }\n}\n\nexport {DomParser}\n","class ArrayUpdateHandler {\n\n    #entries\n    #manipulators\n    #proxyCache\n    #proxiesCreated\n\n    constructor(entries, manipulators) {\n        this.#entries = entries;\n        this.#manipulators = manipulators;\n        this.#proxyCache = new WeakMap();\n        this.#proxiesCreated = new WeakMap();\n    }\n\n    get(target, name) {\n        if (typeof target[name] === 'function' || typeof target[name] !== 'object') {\n            return target[name];\n        }\n\n        // Create the caches for the group of nodes based on the first entry of variables.\n        let node;\n        for (const entry of this.#entries) {\n            node = entry.parent.children[name];\n            if (!this.#proxyCache.has(node)) {\n                const proxy = new Proxy(target[name], new UpdateHandler(entry.variables, entry.manipulators, entry.parent.children[name]));\n                this.#proxyCache.set(node, proxy);\n                this.#proxiesCreated.set(proxy, target[name]);\n                break;\n            }\n        }\n        return this.#proxyCache.get(node);\n    }\n\n    set(target, name, value) {\n        // Prevent proxies already created from being added back to the array.\n        if (this.#proxiesCreated.has(value)) {\n            value = this.#proxiesCreated.get(value);\n        }\n        target[name] = value;\n        if (name === 'length') {\n            this.#entries.forEach(entry => {\n                for (let i = 0; i < entry.parent.children.length - value; i++) {\n                    entry.parent.removeChild(entry.parent.lastChild);\n                }\n            });\n            return true;\n        }\n        this.#manipulators.forEach(manipulator => manipulator.set !== undefined && manipulator.set(name, target[name])) //(x => x.set !== undefined && x.set(name, target[name]))\n        return true;\n    }\n}\n\n\nclass UpdateHandler {\n\n    #variables\n    #manipulators\n    #node\n\n    constructor(variables, manipulators, node) {\n        this.#variables = variables;\n        this.#manipulators = manipulators;\n        this.#node = node;\n    }\n\n    get(target, name) {\n        if (typeof target[name] === 'object' && Array.isArray(target[name]) && this.#variables.get(name)[0].type === \"foreach\") {\n            const updateHandler = new ArrayUpdateHandler(this.#variables.get(name), this.#manipulators.get(name));\n            return new Proxy(target[name], updateHandler);\n        } else if (typeof target[name] === 'object') {\n            return target[name];\n        } else {\n            return target[name];\n        }\n    }\n\n    set(target, name, value) {\n        target[name] = value;\n        this.run(target, name);\n        return true;\n    }\n\n    run(target, name) {\n        this.#manipulators.get(name).forEach(manipulator => {\n            let manipulatedNode = undefined;\n            if (this.#node) {\n                const baseNode = manipulator.variables.path === \"\" ? this.#node : this.#node.querySelector(manipulator.variables.path);\n                if (manipulator.variables.type == \"text\") {\n                    manipulatedNode = baseNode.childNodes[manipulator.variables.index];\n                } else if (manipulator.variables.type == \"attribute\") {\n                    manipulatedNode = baseNode.getAttributeNode(manipulator.variables.name);\n                } else {\n                    manipulatedNode = baseNode;\n                }\n            }\n            manipulator.update(target, manipulatedNode)\n        });\n    }\n}\n\nexport {UpdateHandler, ArrayUpdateHandler}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { DomParser } from \"./parsers.js\"\nimport { DomManipulators } from \"./manipulators.js\"\nimport { UpdateHandler } from \"./update_handlers.js\"\n\n\n/**\n * A view contains the DOM elements to be manipulated by Tico-V.\n */\nclass View {\n\n    #dataProxy\n    #variables\n    #manipulators\n\n    /**\n     * Create a new Tico View\n     * @param {*} variables\n     * @param {*} manipulators\n     */\n    constructor(variables, manipulators) {\n        this.#variables = variables\n        this.#manipulators = manipulators\n    }\n\n    /**\n     * Setter for the data variable.\n     * @param newData\n     */\n    set data(newData) {\n        let updateHandler = new UpdateHandler(this.#variables, this.#manipulators)\n        this.#dataProxy = new Proxy(newData, updateHandler)\n        for(let x of this.#variables.keys()) {\n            updateHandler.run(newData, x)\n        }\n        //this.#variables.keys().forEach(x => updateHandler.run(newData, x))\n    }\n\n    /**\n     * Getter for the data variable.\n     * @returns {*}\n     */\n    get data() {\n        return this.#dataProxy\n    }\n}\n\n/**\n * Bind a view to a mapping of its internal variables.\n */\nexport function bind(template) {\n    const templateNode = typeof template === 'string' ? document.querySelector(template) : template;\n    if (templateNode) {\n        const domparser = new DomParser()\n        const variables = domparser.parse(templateNode)\n        const manipulators = DomManipulators.create(variables)\n        return new View(variables, manipulators)\n    } else {\n        throw new Error(\"Could not find template node\")\n    }\n}\n"],"names":[],"sourceRoot":""}